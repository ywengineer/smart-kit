// Code generated by hertz generator.

package passport

import (
	"context"
	"errors"
	"github.com/bsm/redislock"
	"github.com/bytedance/sonic"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	passport "github.com/ywengineer/smart-kit/passport/biz/model/passport"
	"github.com/ywengineer/smart-kit/passport/internal"
	model2 "github.com/ywengineer/smart-kit/passport/internal/model"
	"github.com/ywengineer/smart-kit/passport/pkg"
	"go.uber.org/zap"
	"gorm.io/gorm"
	"time"
)

// Register .
// @router /register [GET]
func Register(ctx context.Context, c *app.RequestContext) {
	var req passport.RegisterReq
	err := c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, internal.ValidateErr(err))
		return
	}
	authKey := c.GetHeader(pkg.HeaderSmartOauthKey)
	if len(authKey) == 0 {
		c.AbortWithStatusJSON(consts.StatusBadRequest, internal.ValidateErr(errors.New("authKey is empty")))
		return
	}
	_authKey := string(authKey)
	//
	sCtx := ctx.Value(pkg.ContextKeySmart).(pkg.SmartContext)
	id, accessToken, refreshToken, bindKey := "", "", "", ""
	socialName, gender, headImg := "", 0, ""
	// ano
	switch req.Type {
	case passport.AccountType_EMail, passport.AccountType_Mobile:
		c.JSON(consts.StatusNotImplemented, internal.ErrTodo)
		return
	default: // other platform
		auth, err := sCtx.GetAuth(_authKey)
		if err != nil {
			c.AbortWithStatusJSON(consts.StatusBadRequest, internal.ErrAuth)
			return
		}
		tk, err := auth.GetToken(req.GetAuthCode())
		if err != nil {
			hlog.Error("failed to get access token", zap.String("msg", err.Error()), zap.String("authKey", _authKey), zap.String("tag", "register_service"))
			c.AbortWithStatusJSON(consts.StatusBadRequest, internal.ErrAuth)
			return
		}
		usr, err := auth.GetUserInfo(tk.Openid, tk.AccessToken)
		if err != nil {
			hlog.Error("failed to get user info", zap.String("msg", err.Error()), zap.String("authKey", _authKey), zap.String("tag", "register_service"))
			c.AbortWithStatusJSON(consts.StatusBadRequest, internal.ErrAuth)
			return
		}
		// reset bind key
		id, accessToken, refreshToken = usr.UniqueId(), tk.AccessToken, tk.RefreshToken
		socialName, gender, headImg = usr.Nickname, usr.Sex, usr.HeadImgUrl
		bindKey = model2.GetBindCacheKey(req.GetType().String(), id)
		// exists
		if exists, err := sCtx.Redis().Exists(ctx, bindKey).Result(); err != nil {
			hlog.Error("exists check", zap.String("msg", err.Error()), zap.String("deviceId", req.DeviceId), zap.String("tag", "register_service"))
			c.JSON(consts.StatusInternalServerError, internal.ErrCache)
			return
		} else if exists > 0 && req.GetType() != passport.AccountType_Anonymous { // no anonymous already bind to passport, go to log in service
			c.JSON(consts.StatusOK, _login(ctx, sCtx, req.GetType(), id, accessToken, refreshToken))
			return
		}
	}
	//----------------------------------------------- device lock -----------------------------------------------
	lock, err := sCtx.LockMgr().Obtain(ctx, sCtx.GetDeviceLockKey(req.GetDeviceId()), time.Minute, &redislock.Options{
		Metadata:      "register_service",
		RetryStrategy: redislock.NoRetry(),
	})
	if err != nil {
		hlog.Error("get lock err", zap.String("msg", err.Error()), zap.String("deviceId", req.DeviceId), zap.String("tag", "register_service"))
		c.JSON(consts.StatusLocked, internal.ErrDisLock)
		return
	}
	defer lock.Release(ctx)
	cntKey := "register:" + req.DeviceId
	//----------------------------------------------- max per device -----------------------------------------------
	cntNow, err := sCtx.Redis().IncrBy(ctx, cntKey, 0).Result()
	if err != nil {
		hlog.Error("get incr 0 err", zap.String("msg", err.Error()), zap.String("deviceId", req.DeviceId), zap.String("tag", "register_service"))
		c.JSON(consts.StatusInternalServerError, internal.ErrCache)
		return
	} else if cntNow >= 3 {
		hlog.Info("reach max per device", zap.String("deviceId", req.DeviceId), zap.String("tag", "register_service"))
		c.JSON(consts.StatusOK, internal.ErrMaxPerDevice)
		return
	}
	//----------------------------------------------- exists type and id? -----------------------------------------------
	var bind model2.PassportBinding
	// check bind when register from xxx
	if req.GetType() != passport.AccountType_Anonymous {
		// load from db
		r := sCtx.Rdb().
			WithContext(ctx).
			Where(&model2.PassportBinding{BindType: req.GetType().String(), BindId: id}).
			First(&bind)
		// rdb error
		if r.Error != nil && !errors.Is(r.Error, gorm.ErrRecordNotFound) {
			hlog.Error("get data from rdb", zap.String("err", r.Error.Error()), zap.String("tag", "register_service"))
			c.JSON(consts.StatusOK, internal.ErrRdb)
			return
		}
		if bind.PassportId > 0 { // already bound
			//  cache
			if bs, err := sonic.Marshal(bind); err != nil { // json error
				c.JSON(consts.StatusOK, internal.ErrJsonMarshal)
				return // stop
			} else if err = sCtx.Redis().JSONSet(ctx, bindKey, "$", bs).Err(); err != nil { // cache error
				hlog.Error("cache rdb object failed", zap.String("err", err.Error()), zap.String("tag", "register_service"))
				c.JSON(consts.StatusOK, internal.ErrCache)
				return // stop
			} else {
				c.JSON(consts.StatusOK, internal.ErrBoundOther)
				return // stop
			}
		}
	}
	//----------------------------------------------- insert passport and binding -----------------------------------------------
	deviceBytes, _ := sonic.Marshal(req.GetDeviceInfo())
	pst := model2.Passport{
		DeviceId:   req.GetDeviceId(),
		Adid:       req.GetAdid(),
		SystemType: req.GetDeviceInfo()[pkg.Os],
		Locale:     req.GetDeviceInfo()[pkg.Locale],
		Extra:      deviceBytes,
	}
	if err = sCtx.Rdb().Transaction(func(pstBind *model2.PassportBinding) func(tx *gorm.DB) error {
		return func(tx *gorm.DB) error {
			if err := tx.Create(&pst).Error; err != nil { // return any error will roll back
				return err
			}
			*pstBind = model2.PassportBinding{
				PassportId:   pst.ID,
				BindType:     req.GetType().String(),
				BindId:       id,
				AccessToken:  accessToken,
				RefreshToken: refreshToken,
				SocialName:   socialName,
				Gender:       uint(gender),
				IconUrl:      headImg,
			}
			if err := tx.Create(pstBind).Error; err != nil {
				return err
			}
			return nil
		}
	}(&bind)); err != nil {
		hlog.Error("save rdb error", zap.String("msg", err.Error()), zap.String("deviceId", req.DeviceId), zap.String("tag", "register_service"))
		c.JSON(consts.StatusOK, internal.ErrRegisterFail)
		return
	}
	//
	sCtx.Redis().Incr(ctx, cntKey)
	//----------------------------------------------- finish -----------------------------------------------
	// cache
	if _, err := sCtx.Redis().Set(ctx, internal.CacheKeyBoundTypes(pst.ID), req.GetType().String(), 0).Result(); err != nil {
		hlog.Error("cache bind types failed", zap.String("err", err.Error()), zap.String("tag", "register_service"))
		c.JSON(consts.StatusOK, internal.ErrCache)
	} else if bs, err := sonic.Marshal(bind); err != nil { // json error
		c.JSON(consts.StatusOK, internal.ErrJsonMarshal)
	} else if err = sCtx.Redis().JSONSet(ctx, bindKey, "$", bs).Err(); err != nil { // cache error
		hlog.Error("cache new rdb object failed", zap.String("err", err.Error()), zap.String("tag", "register_service"))
		c.JSON(consts.StatusOK, internal.ErrCache)
	} else if pstJsonStr, err := sonic.Marshal(pst); err != nil { // json error
		c.JSON(consts.StatusOK, internal.ErrJsonMarshal)
	} else if err = sCtx.Redis().JSONSet(ctx, internal.CacheKeyPassport(pst.ID), "$", pstJsonStr).Err(); err != nil { // cache error
		hlog.Error("cache passport json object failed", zap.String("err", err.Error()), zap.String("tag", "register_service"))
		c.JSON(consts.StatusOK, internal.ErrCache)
	} else if tk, _, err := sCtx.Jwt().TokenGenerator(map[string]interface{}{ // jwt token
		sCtx.Jwt().IdentityKey: pst.ID,
	}); err != nil {
		hlog.Error("gen token error", zap.String("msg", err.Error()), zap.String("deviceId", req.DeviceId), zap.String("tag", "register_service"))
		c.JSON(consts.StatusOK, internal.ErrGenToken)
	} else {
		c.JSON(consts.StatusOK, pkg.ApiOk(passport.LoginResp{
			PassportId: int64(pst.ID),
			Token:      tk,
			BrandNew:   true,
			Bounds:     []passport.AccountType{req.Type},
			CreateTime: pst.CreatedAt.Unix(),
		}))
	}
}
