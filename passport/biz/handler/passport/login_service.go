// Code generated by hertz generator.

package passport

import (
	"context"
	"errors"
	"github.com/bytedance/sonic"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/redis/go-redis/v9"
	"github.com/ywengineer/smart-kit/passport/biz/model/passport"
	"github.com/ywengineer/smart-kit/passport/pkg"
	"github.com/ywengineer/smart-kit/passport/pkg/model"
	"go.uber.org/zap"
	"gorm.io/gorm"
	"time"
)

// Login .
// @router /login [GET]
func Login(ctx context.Context, c *app.RequestContext) {
	var err error
	var req passport.LoginReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, validateErr(err))
		return
	}
	//
	sCtx := ctx.Value(pkg.ContextKeySmart).(pkg.SmartContext)
	bindKey := model.GetBindCacheKey(req.GetType().String(), req.GetId())
	// query bind cache
	bkv, err := sCtx.Redis().JSONGet(ctx, bindKey).Result()
	var bind model.PassportBinding
	//
	if errors.Is(err, redis.Nil) || len(bkv) == 0 { // query bind db
		r := sCtx.Rdb().
			WithContext(ctx).
			Where(&model.PassportBinding{BindType: req.GetType().String(), BindId: req.GetId()}).
			First(&bind)
		expire := 0
		if errors.Is(r.Error, gorm.ErrRecordNotFound) { // no data
			// cache null value for one minute
			bind.CreatedAt = time.Now()
			expire = 15 - bind.CreatedAt.Second()%10
		} else if r.Error != nil {
			hlog.Error("get data from rdb", zap.String("err", r.Error.Error()), zap.String("tag", "login_service"))
			c.JSON(consts.StatusOK, ErrRdb)
			return
		}
		if bs, err := sonic.Marshal(bind); err != nil { // json error
			c.JSON(consts.StatusOK, ErrJsonMarshal)
			return // stop
		} else if err = sCtx.Redis().JSONSet(ctx, bindKey, "$", bs).Err(); err != nil { // cache error
			hlog.Error("cache rdb object failed", zap.String("err", err.Error()), zap.String("tag", "login_service"))
			c.JSON(consts.StatusOK, ErrCache)
			return // stop
		} else if expire > 0 {
			sCtx.Redis().Expire(ctx, bindKey, time.Duration(expire)*time.Second)
		}
	} else if err != nil {
		hlog.Error("unreachable cache", zap.String("err", err.Error()), zap.String("tag", "login_service"))
		c.JSON(consts.StatusOK, ErrCache)
		return // stop
	} else if err = sonic.UnmarshalString(bkv, &bind); err != nil { // cache error
		hlog.Error("broken cache schema", zap.String("err", err.Error()), zap.String("tag", "login_service"))
		c.JSON(consts.StatusOK, ErrJsonUnmarshal)
		return // stop
	}
	//-------------------------------------- cache null
	if bind.ID <= 0 {
		c.JSON(consts.StatusOK, ErrLoginTry)
		return // stop
	}
	//-------------------------------------- token match --------------------------------------
	if bind.AccessToken != req.GetAccessToken() {
		c.JSON(consts.StatusOK, ErrInvalidToken)
	} else if tk, _, err := sCtx.Jwt().TokenGenerator(map[string]interface{}{ // jwt token
		"id": bind.PassportId,
	}); err != nil {
		c.JSON(consts.StatusOK, ErrGenToken)
	} else {
		c.JSON(consts.StatusOK, pkg.ApiOk(passport.LoginResp{
			PassportId: int64(bind.PassportId),
			Token:      tk,
			BrandNew:   false,
			CreateTime: time.Now().Unix(),
		}))
	}
}
