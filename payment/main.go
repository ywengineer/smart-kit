// Code generated by hertz generator.

package main

import (
	"context"
	"errors"
	"fmt"
	"time"

	"gitee.com/ywengineer/smart-kit/payment/internal/queue/handler"
	"gitee.com/ywengineer/smart-kit/pkg/utilk"
	"github.com/hibiken/asynq"
	"gorm.io/sharding"

	"gitee.com/ywengineer/smart-kit/payment/internal/config"
	"gitee.com/ywengineer/smart-kit/payment/internal/queue"
	_ "gitee.com/ywengineer/smart-kit/payment/internal/verifier"
	"gitee.com/ywengineer/smart-kit/payment/pkg/model"
	"gitee.com/ywengineer/smart-kit/pkg/apps"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/robfig/cron/v3"
	"gorm.io/gorm"
)

func main() {
	rootCtx, cn := context.WithCancel(context.Background()) // 初始化 cron 实例（支持时区设置，默认 UTC，这里指定为本地时区）
	c := cron.New(cron.WithLocation(time.Local))
	//
	if h := apps.NewHertzApp("smart-payment",
		apps.NewDefaultContext,
		apps.WithStartupHandle(func(ctx apps.SmartContext) {
			//--------------------------------------------------------------------------------------------------
			if err := config.Watch(rootCtx, ctx.GetNacosConfig(), func(c config.Payment) {

			}); err != nil {
				hlog.CtxFatalf(rootCtx, "watch payment application config error: %v", err)
			} else {
				hlog.CtxInfof(rootCtx, "watch payment application config succeed, %+v", config.Get().Auth.Realm)
			}
			//
			queue.Setup(rootCtx, ctx, config.Get().Queue, map[queue.TaskType]asynq.HandlerFunc{
				queue.PurchaseNotify: handler.HandlePurchaseNotify,
				queue.Test:           handler.Test,
			})
			//--------------------------------------------------------------------------------------------------
			c.Schedule(cron.Every(time.Second*30), config.MetaUpdateJob(rootCtx))
			//--------------------------------------------------------------------------------------------------
			sqlRunner(ctx.Rdb())
			//--------------------------------------------------------------------------------------------------
		}),
		apps.WithShutdownHandle(func(ctx context.Context) {
			c.Stop()
			queue.Shutdown()
			cn()
		}),
		apps.WithMgrAuth(config.BasicAuth()),
		apps.WithGormPlugins(shardingOrder()),
		apps.WithModels(&model.Purchase{}),
	); h != nil {
		c.Start()
		register(h)
		h.Spin()
	}
}

func shardingOrder() gorm.Plugin {
	var shards uint64 = 64
	return sharding.Register(sharding.Config{
		ShardingKey:         "transaction_id",
		NumberOfShards:      uint(shards),
		PrimaryKeyGenerator: sharding.PKSnowflake,
		ShardingAlgorithm: func(columnValue any) (suffix string, err error) {
			if transactionID, ok := columnValue.(string); ok {
				return fmt.Sprintf("_%02d", utilk.Hash(transactionID)%shards), nil
			}
			return "", errors.New("invalid transaction_id")
		},
		ShardingSuffixs: func() (suffixs []string) {
			numberOfShards := int(shards)
			for i := 0; i < numberOfShards; i++ {
				suffixs = append(suffixs, fmt.Sprintf("_%02d", i%numberOfShards))
			}
			return
		},
	}, model.Purchase{})
}

func sqlRunner(db *gorm.DB) {
	//hlog.Info(db.ToSQL(func(tx *gorm.DB) *gorm.DB {
	//	return tx.WithContext(context.Background()).Clauses(clause.OnConflict{
	//		Columns:   []clause.Column{{Name: "passport"}},                            // 冲突字段（唯一索引）
	//		DoUpdates: clause.AssignmentColumns([]string{"updated_at", "deleted_at"}), // 更新字段
	//	}).Create(&model2.WhiteList{Passport: 100})
	//}))
}
